#!/usr/xpg4/bin/sh
# RB 2007/02/16
# $Id$
#
# Backup local filesystems to local or remote device.
#

PATH=/usr/sbin:/usr/xpg4/bin:/usr/bin:$PATH
SHELL=/usr/xpg4/bin/sh

BASE=$(cd $(dirname $0)/..; pwd)
LOG_FILE=$BASE/log/backup.log
TOC_FILE=$BASE/log/toc
EXCLUDE_FILE=$BASE/etc/exclude
SCRIPT_FILE=$BASE/etc/scripts
NOSNAP_FILE=$BASE/etc/nosnap
MAIL_USERS=
SCRIPT_BASE=$BASE/scripts
HOSTNAME=$(hostname)

function usage
{
	echo "USAGE: $0 [options] [action]"
	echo "Options:"
	echo "       -f [[user@]host:]device  # backup device (default: /dev/rmt/0cn)"
	echo "       -b path                  # backing-store for ufs snapshots (default: /snap)"
	echo "       -t                       # dry run without tape"
	echo "       -n                       # ignore pre/post scripts"
	echo "       -e                       # don't eject the tape"
	echo "       -v                       # send script output to terminal"
	echo "Actions:"
	echo "       help                     # display this message (default)"
	echo "     * backup                   # execute backup"
	echo "     * check                    # view backup log"
	echo "     * restore [/mountpoint]    # execute restore"
	echo "     * toc                      # display table of contents"
	echo "       position                 # position tape"
	echo "       register                 # register with logadm"
	echo "       rotate                   # force rotation of backup log"
	exit $1
}

while getopts b:cef:mnr:stvh c
do
	case $c in
	b)	BACKING_STORE=$OPTARG
		;;
	c)	NO_COLOUR=1
		;;
	e)	NO_EJECT=1
		;;
	f)	DUMP_DEVICE=$OPTARG
		;;
	m)	MAIL_LOG=1
		;;
	n)	NO_SCRIPT=1
		;;
	r)	RSH=$OPTARG
		;;
	s)	RSH="ssh -o BatchMode=yes"
		;;
	t)	NO_TAPE=1
		DUMP_DEVICE=/dev/null
		;;
	v)	OUTPUT=/dev/stdout
		;;
	h)	usage 0
		;;
	*)	usage 1
		;;
	esac
done
shift $((OPTIND - 1))

# Set defaults
: ${ACTION:=${1:-help}}
: ${DUMP_DEVICE:=/dev/rmt/0cn}
: ${RSH:=rsh}
: ${OUTPUT:=/dev/null}
: ${NO_TAPE:=0}
: ${NO_REWIND:=0}
: ${NO_EJECT:=0}
: ${NO_SCRIPT:=0}
: ${NO_COLOUR:=0}
: ${FSTYPES:=ufs zfs}		# filesystem types that we wish to backup
: ${PAX_FORMAT:=xustar}
: ${SNAPSHOT_ZFS:=1}		# should zfs filesystems be snapshot?
: ${SNAPSHOT_UFS:=1}		# should ufs filesystems be snapshot?
: ${FSSNAP_MAXSIZE:=512m}	# maximum size for the ufs snapshot backing store
: ${BACKING_STORE:=/snap}	# location of the ufs snapshot backing store
: ${MAIL_LOG:=0}
: ${MAIL_USERS:=cs.ops@brookes.ac.uk}

# Setup syntax highlighting
COLOUR_normal="[0m"
COLOUR_dgrey="[1;30m"
COLOUR_dred="[0;31m"
COLOUR_red="[1;31m"
COLOUR_dgreen="[0;32m"
COLOUR_lgreen="[1;32m"
COLOUR_brown="[0;33m"
COLOUR_yellow="[1;33m"
COLOUR_blue="[1;34m"
COLOUR_purple="[0;35m"
COLOUR_pink="[1;35m"
COLOUR_cyan="[1;36m"
COLOUR_lgrey="[0;37m"
COLOUR_white="[1;37m"


# Set remote command defaults
AWK=/usr/xpg4/bin/awk
CAT=/usr/bin/cat
DATE=/usr/xpg4/bin/date
DD=/usr/bin/dd
ENV=/usr/xpg4/bin/env
FIND=/usr/xpg4/bin/find
FSSNAP=/usr/sbin/fssnap
GREP=/usr/xpg4/bin/grep
LESS=/usr/bin/less
if [[ -x /usr/sbin/logadm ]]; then
	LOGADM=/usr/sbin/logadm
else
	LOGADM=$BASE/bin/logadm8
fi
MAIL=/usr/bin/mailx
MKTEMP=/usr/bin/mktemp
MT=/usr/bin/mt
PAX=/usr/bin/pax
PR=/usr/xpg4/bin/pr
RM=/usr/xpg4/bin/rm
SED=/usr/xpg4/bin/sed
SLEEP=/usr/bin/sleep
TEE=/usr/bin/tee
UFSDUMP=/usr/sbin/ufsdump
UFSRESTORE=/usr/sbin/ufsrestore
ZFS=/sbin/zfs

# Calculate additional settings
REMOTE=$(echo $DUMP_DEVICE | $GREP :)
if [[ -n "$REMOTE" ]]; then
	echo $DUMP_DEVICE | $SED -e 's/:/ /' | read DUMP_HOST DUMP_DEVICE
fi

# Print a pretty datestamp
function datestamp
{
	$DATE +'%Y-%m-%d %H:%M:%S'
}

# Print a separator
function separator
{
	echo "------------------------------------------------------------------------"
}

# Highlight piped data
function highlight
{
	if (( NO_COLOUR > 0 )); then
		$CAT
	else
		$SED \
			-e "s/DUMP IS DONE/${COLOUR_lgreen}&${COLOUR_normal}/" \
			-e "s/NEEDS ATTENTION.*/${COLOUR_dred}&${COLOUR_normal}/" \
			-e "s/ERROR.*/${COLOUR_dred}&${COLOUR_normal}/" \
			-e "s/NO TAPE.*/${COLOUR_dred}&${COLOUR_normal}/" \
			-e "s/BEGIN/${COLOUR_dgreen}&${COLOUR_normal}/" \
			-e "s/COMPLETE/${COLOUR_dgreen}&${COLOUR_normal}/" \
			-e "s/^-*$/${COLOUR_dgrey}&${COLOUR_normal}/" \
			-e "s/^==>.*/${COLOUR_white}&${COLOUR_normal}/" \
			-e "s/^-->.*/${COLOUR_white}&${COLOUR_normal}/" \
			-e "s/^#.*/${COLOUR_dgrey}&${COLOUR_normal}/"
	fi
}

# Register log with logadm
function log_register
{
	$LOGADM -w backup -C 28 -p never -z 7 -t '$file.$N' "{$LOG_FILE,$TOC_FILE}"
	if (( $? > 0 )); then
		echo "ERROR: registering logfile with logadm"
		usage 1
	else
		echo "Successfully registered with logadm"
	fi
}

# Rotate log
function log_rotate
{
	$LOGADM backup -p now
	if (( $? > 0 )); then
		echo "ERROR: rotating logfile ($LOG_FILE)"
		usage 1
	fi
}

# Pipe input to backup log
function log_pipe
{
	$TEE -a $LOG_FILE > $OUTPUT
}

# Read backup log
function log_page
{
	$CAT $LOG_FILE | highlight | $ENV LESS= $LESS -er
}

# Check tape status, potentially on remote host
function tape_status
{
	if (( NO_TAPE > 0 )); then
		echo "--> running without tape"
	else
		echo "--> checking tape status"
		# The ${REMOTE:+foo} syntax returns "foo" if FOO is set,
		# otherwise nothing.
		${REMOTE:+$RSH $DUMP_HOST} $MT -f $DUMP_DEVICE status
		if (( $? > 0 )); then
			echo "--> NO TAPE: dump device reset to /dev/null"
			NO_TAPE=1
		fi
	fi
}

# Rewind tape, potentially on remote host
function tape_rewind
{
	if (( NO_TAPE > 0 || NO_REWIND > 0 )); then
		echo "--> skipped tape rewind" 1>&2
	else
		echo "--> rewinding tape" 1>&2
		${REMOTE:+$RSH $DUMP_HOST} $MT -f $DUMP_DEVICE rewind
	fi
	return $?
}

# Eject tape, potentially on remote host
function tape_eject
{
	if (( NO_TAPE > 0 || NO_EJECT > 0 )); then
		echo "--> skipped tape eject"
	else
		echo "--> ejecting tape"
		${REMOTE:+$RSH $DUMP_HOST} $MT -f $DUMP_DEVICE offline
	fi
	return $?
}

# Write data to tape using dd, potentially on remote host
# $* = dd directives
#
# For dumper programs which expect to write to a file or device rather than
# into a pipe, this can be used to set up a named pipe using the >(tape_write)
# syntax.
function tape_write
{
	if (( NO_TAPE > 0 )); then
		echo "--> NO TAPE: piping to /dev/null"
		$DD $* of=/dev/null
	else
		if [[ -n "$REMOTE" ]]; then
			# Establish a tunnel to dd(1) running on the remote machine
			$RSH $DUMP_HOST "$DD $* of=$DUMP_DEVICE"
		else
			# Run dd(1) locally, piping from stdin to $DUMP_DEVICE
			$DD $* of=$DUMP_DEVICE
		fi
	fi
}

# Read data from tape using dd, potentially on remote host
# $* = dd directives
#
# For restore programs which expect to read from a file or device rather than
# from a pipe, this can be used to set up a named pipe using the <(tape_read)
# syntax.
function tape_read
{
	if (( NO_TAPE > 0 )); then
		echo "--> NO TAPE: aborting"
		exit 1
	else
		if [[ -n "$REMOTE" ]]; then
			# Establish a tunnel to dd(1) running on the remote machine
			$RSH $DUMP_HOST "$DD $* if=$DUMP_DEVICE"
		else
			# Run dd(1) locally, piping from $DUMP_DEVICE to stdout
			$DD $* if=$DUMP_DEVICE
		fi
	fi
}

# Position tape interactively
# $1 = FILENO
function tape_position
{
	FILENO=$1
	while [[ -z "$FILENO" ]]; do
		read FILENO?"Enter File No.: "
	done
	$MT -f $DUMP_DEVICE asf $FILENO
}

# Generate a ToC for the pending backup
function toc_create
{
	echo "--> generating table of contents"
	if [[ -f $EXCLUDE_FILE ]]; then
		# This 'magic' line joins all the non-comment, non-blank lines (i.e.
		# the mountpoints) in the exclude file with a '|' character (regular
		# expression "OR"), prefixes with '^(' and suffixes with ')$'.
		# This produces a regular expression of the form '^(foo|bar|bim)$'
		# which is later used to determine if a given filesystem should be
		# excluded.
		EXCLUDE=$($AWK 'BEGIN {printf "^(";} $0 !~ /#/ && $0 != "" {printf "%s%s", (i++>0)?"|":"", $0;} END {printf ")$";}' $EXCLUDE_FILE)
	else
		echo "--> no filesystem excludes: $EXCLUDE_FILE not found"
		# If the exclude file doesn't exist, match nothing.
		EXCLUDE='^$'
	fi
	# Loop over each supported filesystem type
	for t in $FSTYPES; do
		# Look for all instances of the current filesystem type in the mnttab,
		# whole mountpoint does not match the EXCLUDE regular expression, and
		# print the type, device and mointpoint.
		$AWK -v fstype=$t -v exclude=$EXCLUDE \
			'$3 == fstype && $2 !~ exclude {print $3, $1, $2}' \
		< /etc/mnttab
	done | $PR -tn > $TOC_FILE
	STATUS=$?
	echo "--> table of contents:"
	$CAT $TOC_FILE
	return $STATUS
}

# Write backup ToC to dump device
function toc_write
{
	echo "--> writing table of contents"
	# Write a timestamp followed by the TOC_FILE to tape_write via a standard
	# pipe. Written as raw data, this can later be read with a simple dd(1).
	echo Backup of $HOSTNAME: $(datestamp) | $CAT - $TOC_FILE | tape_write
	return $?
}

# Retrieve and display the ToC from dump device
function toc_read
{
	tape_rewind
	if (( $? > 0 || NO_TAPE > 0 || NO_REWIND > 0 )); then
		echo "ERROR: accessing tape" 1>&2
		exit 1
	fi
	$DD if=$DUMP_DEVICE
}

# Reformat script output
function script_pipe
{
	$SED -e 's/^/# /'
}

# Run pre/post scripts for mountpoint
# $1 = pre|post
# $2 = MOUNTPOINT
function script_process
{
	if (( NO_SCRIPT > 0 )); then
		echo "--> skipping $1-backup scripts for $2"
		return 0
	fi
	if [[ -f "$SCRIPT_FILE" ]]; then
		echo "--> processing $1-backup scripts for $2"
		$AWK '$1 ~ /^(pre|post)$/' $SCRIPT_FILE \
		| while read WHEN FS COMMAND; do
			if [[ "$1" == "$WHEN" && "$2" == "$FS" ]]; then
				echo "--> executing: ( $COMMAND )"
				$SHELL -c "$COMMAND" 2>&1 | script_pipe
			fi
		done
	else
		echo "--> skipping $1-backup scripts: $SCRIPT_FILE not found"
	fi
}

# Mail interested parties
function mail_users
{
	$MAIL -s "Message from $HOSTNAME: backup failed" $MAIL_USERS < $LOG_FILE
}

# Check if a zfs snapshot exists
# $1 = SNAPSHOT
# Returns: 0 if snapshot exists, >0 otherwise
function snap_exists_zfs
{
	$ZFS list -t snapshot -Ho name $1 >/dev/null 2>&1
	return $?
}

# Check if a ufs snapshot exists
# $1 = MOUNTPOINT
# Returns: 0 if snapshot exists, 1 otherwise
function snap_exists_ufs
{
	$FSSNAP -i $1 | read STATE
	if [[ -n "$STATE" ]]; then
		return 0
	else
		return 1
	fi
}

# Create a snapshot of a zfs filesystem
# $1 = FILESYSTEM
# $2 = MOUNTPOINT
# Result: snapshot mountpoint or normal mountpoint if snapshot fails.
function snap_create_zfs
{
	HAS_SNAP=0
	# Determine whether the given mountpoint appears in the nosnap file.
	# First a named pipe is created containing the non-comment, non-blank lines
	# of NOSNAP_FILE.
	# This named pipe is used as the pattern file for grep (-f), which does a
	# fixed string search (-F), counting (-c) the number of times that entries
	# in the pattern file appear in the the string received on stdin (the
	# mountpoint). If the mountpoint doesn't appear in nosnap, this returns 0,
	# otherwise 1.
	NOSNAP=$(echo $2 | $GREP -cF -f <(echo NONE | $CAT - $NOSNAP_FILE | $GREP -v '#' | $GREP -v '^$'))
	if (( SNAPSHOT_ZFS > 0 && NOSNAP == 0 )); then
		echo "--> creating zfs snapshot of $2" 1>&2
		SNAPSHOT=$2/.zfs/snapshot/backup
		$ZFS snapshot $1@backup
		if [[ $? -eq 0 && -d $SNAPSHOT ]]; then
			echo "--> snapshot successfully created" 1>&2
			echo $SNAPSHOT
			HAS_SNAP=1
		else
			echo "--> ERROR: snapshot creation failed" 1>&2
			echo "--> proceeding with non-snap backup" 1>&2
			echo $2
		fi
	else
		echo "--> skipped creation of zfs snapshot for $2" 1>&2
		echo $2
	fi
	return $HAS_SNAP
}

# Create a snapshot of a ufs filesystem
# $1 = DEVICE
# $2 = MOUNTPOINT
# Result: snapshot device or original device if snapshot fails.
# Side-effects: sets HAS_SNAP=1 if snapshot created, 0 otherwise.
function snap_create_ufs
{
	HAS_SNAP=0
	NOSNAP=$(echo $2 | $GREP -cF -f <(echo NONE | $CAT - $NOSNAP_FILE | $GREP -v '#' | $GREP -v '^$'))
	if (( SNAPSHOT_UFS > 0 && NOSNAP == 0 )); then
		echo "--> creating ufs snapshot: $2" 1>&2
		# The following prints the path to the snap device
		$FSSNAP -F ufs -o maxsize=FSSNAP_MAXSIZE,bs=$BACKING_STORE,unlink $2
		if (( $? > 0 )); then
			echo "--> ERROR: snapshot creation failed" 1>&2
			echo "--> proceeding with non-snap backup" 1>&2
			echo $1
		else
			echo "--> snapshot successfully created" 1>&2
			HAS_SNAP=1
		fi
	else
		echo "--> skipped creation of ufs snapshot for $2" 1>&2
		echo $1
	fi
	return $HAS_SNAP
}

# Destroy the snapshot of a zfs filesystem
# $1 = FILESYSTEM
# $2 = MOUNTPOINT
# Result: nothing
function snap_delete_zfs
{
	if ! snap_exists_zfs $1@backup; then
		echo "--> ERROR: snapshot of $2 has disappeared"
		return 1
	fi
	echo "--> deleting zfs snapshot of $2"
	$ZFS destroy $1@backup
	if (( $? > 0 )); then
		echo "--> ERROR: snapshot deletion failed"
	else
		echo "--> snapshot successfully deleted"
	fi
}

# Destroy the snapshot of a ufs filesystem
# $1 = DEVICE
# $2 = MOUNTPOINT
# Result: nothing
function snap_delete_ufs
{
	if ! snap_exists_ufs $2; then
		echo "--> ERROR: snapshot of $2 has disappeared"
		return 1
	fi
	echo "--> deleting ufs snapshot of $2"
	$FSSNAP -d $2
	if (( $? > 0 )); then
		echo "--> ERROR: snapshot deletion failed"
	else
		echo "--> snapshot successfully deleted"
	fi
}

# Dump a zfs filesystem (snapshot) via pax
# $1 = FILESYSTEM
# $2 = MOUNTPOINT
# $3 = SNAPSHOT (mountpoint)
function dump_zfs
{
	cd $3
	if (( $? > 0 )); then
		echo "==> ERROR: $3 not found, dump of $2 failed: $(datestamp)"
		return 1
	fi
	echo "==> BEGIN: dump of $2 via pax: $(datestamp)"
	echo "--> running pax..."
	$FIND . -xdev '!' '(' -type d -o -type s ')' -print \
	| $PAX -w -pe -x $PAX_FORMAT -X -s '#^./##' -f >(tape_write obs=63k)
	STATUS=$?
	if (( STATUS > 0 )); then
		echo "==> ERROR: dump of $2 failed: $(datestamp)"
	else
		echo "==> COMPLETE: dump of $2 successful: $(datestamp)"
	fi
	cd - >/dev/null
	# Give the >() pipe time to close
	$SLEEP 5
	return $STATUS
}

# Dump a ufs filesystem (snapshot) via ufsdump
# $1 = DEVICE
# $2 = MOUNTPOINT
# $3 = SNAPSHOT (device)
function dump_ufs
{
	echo "==> BEGIN: dump of $2 via ufsdump: $(datestamp)"
	echo "--> running ufsdump..."
	$UFSDUMP 0cf >(tape_write obs=63k) $SNAPSHOT
	STATUS=$?
	if (( STATUS > 0 )); then
		echo "==> ERROR: dump of $2 failed: $(datestamp)"
	else
		echo "==> COMPLETE: dump of $2 successful: $(datestamp)"
	fi
	# Give the >() pipe time to close
	$SLEEP 5
	return $STATUS
}

# Backup a filesystem
# $1 = FSTYPE
# $2 = DEVICE
# $3 = MOUNTPOINT
function backup_fs
{
	echo "==> Backing up $HOSTNAME:$3 to ${REMOTE:+$DUMP_HOST:}$DUMP_DEVICE"
	script_process pre $3
	SNAPSHOT=$(snap_create_$1 $2 $3)
	# $? > 0 implies snapshot was successful
	if (( $? > 0 )); then
		# ensure snapshot gets deleted
		trap "snap_delete_$1 $2 $3" ERR INT EXIT
		# run post-scripts early as we have a snapshot
		script_process post $3
	else
		# ensure post scripts get run
		trap "script_process post $3" ERR INT EXIT
	fi
	dump_$1 $2 $3 $SNAPSHOT
}

# Backup all local filesystems
function backup_all
{
	log_rotate
	{
		echo "===> Backup commenced: $(datestamp)"
		tape_status
		tape_rewind
		separator
		toc_create
		toc_write
		separator
		script_process pre ALL
		while read NUM FSTYPE DEVICE MOUNTPOINT; do
			separator
			backup_fs $FSTYPE $DEVICE $MOUNTPOINT
			(( $? > 0 )) && MAIL_LOG=1
		done < $TOC_FILE
		separator
		script_process post ALL
		separator
		tape_eject
		echo "===> Backup completed: $(datestamp)"
	} 2>&1 | log_pipe
}

# Restore files from a filesystem
# $1 = FILESYSTEM
function restore
{
	ROOT=$1
	echo "==> initiating restore ${ROOT:+from $ROOT}"
	echo "--> WARNING: restore will be to the current directory ($(pwd))!"
	while [[ -z "$ROOT" ]]; do
		read ROOT?"Enter source filesystem mountpoint: "
	done

	TOC_TEMP=$($MKTEMP)
	toc_read > $TOC_TEMP
	tail +1 $TOC_TEMP | while read NUM FSTYPE DEVICE MOUNTPOINT; do
		if [[ "$MOUNTPOINT" = "$ROOT" ]]; then
			echo "--> matched entry in table of contents: $NUM $FSTYPE $DEVICE $MOUNTPOINT"
			break
		fi
	done
	$RM $TOC_TEMP

	if (( NUM )); then
		case $FSTYPE in
		zfs)
			tape_position $NUM
			echo "--> pax does not support interaction"
			read FILE?"Enter file patterns to restore: "
			# pax(1) expects to read from a file, so give it a named pipe.
			$PAX -rvf <(tape_read ibs=63k) $FILE
			;;
		ufs)
			if [[ -n "$REMOTE" ]]; then
				echo "--> ERROR: cannot use remote device ($DUMP_HOST:$DUMP_DEVICE) for ufs restore"
			else
				tape_position $NUM
				echo "--> initiating interactive restore"
				# ufsrestore(1) doesn't happily read from a named pipe, so for
				# now we support local restores only, and it reads directly
				# from DUMP_DEVICE!
				$UFSRESTORE ivf $DUMP_DEVICE
			fi
			;;
		*)
			echo "--> ERROR: Unrecognized filesystem type: $FSTYPE"
			;;
		esac
	else
		echo "--> ERROR: no match in table of contents"
	fi
}

# Carry out action
case $ACTION in
backup)
	backup_all; (( MAIL_LOG > 0 )) && mail_users || exit 0
	;;
restore)
	restore $2
	;;
check)
	log_page
	;;
toc)
	toc_read
	;;
position)
	tape_position $2
	;;
register)
	log_register
	;;
rotate)
	log_rotate
	;;
help)
	usage 0
	;;
*)
	echo "Not implemented"; usage 1
	;;
esac

