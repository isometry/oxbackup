#!/bin/ksh
# RB 2007/02/16
# $Id$
#
# Backup local filesystems to local or remote device.
#

PATH=/usr/sbin:/usr/xpg4/bin:/usr/bin:$PATH

BASE=$(cd $(dirname $0)/..; pwd)
LOG_FILE=$BASE/log/backup.log
TOC_FILE=$BASE/log/toc
EXCLUDE_FILE=$BASE/etc/exclude
SCRIPT_FILE=$BASE/etc/scripts
NOSNAP_FILE=$BASE/etc/nosnap
MAIL_USERS=
SCRIPT_BASE=$BASE/scripts
HOSTNAME=$(hostname)

function usage
{
	echo "USAGE: $0 [options] [action]"
	echo "Options:"
	echo "       -f [[user@]host:]device  # backup device"
	echo "       -t                       # no tape"
	echo "       -n                       # no scripts"
	echo "       -e                       # no eject"
	echo "       -v                       # view output"
	echo "Actions:"
	echo "       backup                   # execute backup (default)"
	echo "       check                    # view backup log"
	echo "       toc                      # display table of contents"
	echo "       position                 # position tape"
	echo "       register                 # register with logadm"
	echo "       rotate                   # rotate backup log"
	exit $1
}

while getopts cef:mnr:stvh c
do
	case $c in
	c)	NO_COLOUR=1
		;;
	e)	NO_EJECT=1
		;;
	f)	DUMP_DEVICE=$OPTARG
		;;
	m)	MAIL_LOG=1
		;;
	n)	NO_SCRIPT=1
		;;
	r)	RSH=$OPTARG
		;;
	s)	RSH="ssh -o BatchMode=yes"
		;;
	t)	NO_TAPE=1
		DUMP_DEVICE=/dev/null
		;;
	v)	OUTPUT=/dev/stdout
		;;
	h)	usage 0
		;;
	*)	usage 1
		;;
	esac
done
shift $((OPTIND - 1))

# Set defaults
: ${ACTION:=${1:-backup}}
: ${DUMP_DEVICE:=/dev/rmt/0cn}
: ${RSH:=rsh}
: ${OUTPUT:=/dev/null}
: ${NO_TAPE:=0}
: ${NO_REWIND:=0}
: ${NO_EJECT:=0}
: ${NO_SCRIPT:=0}
: ${NO_COLOUR:=0}
: ${FSTYPES:=ufs zfs}
: ${PAX_FORMAT:=pax}
: ${SNAPSHOT_ZFS:=1}
: ${SNAPSHOT_UFS:=1}
: ${BACKING_STORE:=/var/tmp}
: ${MAIL_LOG:=0}
: ${MAIL_USERS:=p0073773@brookes.ac.uk}

# Setup syntax highlighting
COLOUR_normal="[0m"
COLOUR_dgrey="[1;30m"
COLOUR_red="[1;31m"
COLOUR_green="[1;32m"
COLOUR_yellow="[1;33m"
COLOUR_dblue="[1;34m"
COLOUR_pink="[1;35m"
COLOUR_lblue="[1;36m"
COLOUR_white="[1;37m"

set -A SYNTAX \
	"'s/.*(BEGIN|COMPLETE).*/${COLOUR_white}&${COLOUR_normal}/'" \
	"'s/DUMP IS DONE/${COLOUR_green}&${COLOUR_normal}/'" \
	"'s/.*(ERROR|failed).*/${COLOUR_red}&${COLOUR_normal}/'" \
	"'s/^#.*/${COLOUR_dgrey}&${COLOUR_normal}/'"

# Set remote command defaults
GREP=/usr/xpg4/bin/grep
AWK=/usr/xpg4/bin/awk
MT=/usr/bin/mt
DD=/usr/bin/dd
PAX=/usr/bin/pax
UFSDUMP=/usr/sbin/ufsdump

# Calculate additional settings
REMOTE=$(echo $DUMP_DEVICE | $GREP :)
if [[ -n "$REMOTE" ]]; then
	echo $DUMP_DEVICE | sed 's/:/ /' | read DUMP_HOST DUMP_DEVICE
fi

# Print a pretty datestamp
function datestamp
{
	date +'%Y-%m-%d %H:%M:%S'
}

# Print a separator
function separator
{
	echo "------------------------------------------------------------------------"
}

# Highlight piped data
# $1 = COLOUR (fg;bg)
# $2 = PATTERN
function highlight
{
	if (( NO_COLOUR > 0 )); then
		cat
	else
		sed ${SYNTAX[@]}
	fi
}

# Register log with logadm
function log_register
{
	logadm -w backup -C 14 -p never -z 3 $LOG_FILE
	if (( $? > 0 )); then
		echo "ERROR: registering logfile with logadm"
		usage 1
	else
		echo "Successfully registered with logadm"
	fi
}

# Rotate log
function log_rotate
{
	logadm backup -p now
	if (( $? > 0 )); then
		echo "ERROR: rotating logfile ($LOG_FILE)"
		usage 1
	fi
}

# Pipe input to backup log
function log_pipe
{
	tee -a $LOG_FILE > $OUTPUT
}

# Read backup log
function log_page
{
	cat $LOG_FILE | highlight | ${PAGER:-less}
}

# Check tape status
function tape_status
{
	if (( NO_TAPE > 0 )); then
		echo "--> running without tape"
	else
		echo "--> checking tape status"
		${REMOTE:+$RSH $DUMP_HOST} $MT -f $DUMP_DEVICE status
		NO_TAPE=$?
	fi
}

# Rewind tape
function tape_rewind
{
	if (( NO_TAPE > 0 || NO_REWIND > 0 )); then
		echo "--> skipped tape rewind"
	else
		echo "--> rewinding tape"
		${REMOTE:+$RSH $DUMP_HOST} $MT -f $DUMP_DEVICE rewind
	fi
	return $?
}

# Eject tape
function tape_eject
{
	if (( NO_TAPE > 0 || NO_EJECT > 0 )); then
		echo "--> skipped tape eject"
	else
		echo "--> ejecting tape"
		${REMOTE:+$RSH $DUMP_HOST} $MT -f $DUMP_DEVICE offline
	fi
	return $?
}

# Write data to tape
function tape_write
{
	if (( NO_TAPE > 0 )); then
		echo "--> NO TAPE: piping to /dev/null"
		$DD obs=63k of=/dev/null
	else
		${REMOTE:+$RSH $DUMP_HOST} $DD obs=63k of=$DUMP_DEVICE
	fi
}

# Position tape interactively
function tape_position
{
	toc_read
	read fn?"Select file no: "
	$MT -f $DUMP_DEVICE asf $fn
}

# Generate a ToC for the pending backup
function toc_create
{
	echo "--> generating table of contents:"
	if [[ -f $EXCLUDE_FILE ]]; then
		EXCLUDE=$($AWK 'BEGIN {printf "^(";} $0 !~ /#/ && $0 != "" {printf "%s%s", (i++>0)?"|":"", $0;} END {printf ")$";}' $EXCLUDE_FILE)
	else
		echo "--> no filesystem excludes: $EXCLUDE_FILE not found"
		EXCLUDE='^$'
	fi
	for t in $FSTYPES; do
		$AWK -v fstype=$t -v exclude=$EXCLUDE \
			'$3 == fstype && $2 !~ exclude {print $3, $1, $2}' \
		< /etc/mnttab
	done | pr -tn > $TOC_FILE
	STATUS=$?
	cat $TOC_FILE
	return $STATUS
}

# Write backup ToC to dump device
function toc_write
{
	echo "--> writing table of contents"
	echo Backup of $HOSTNAME: $(datestamp) | cat - $TOC_FILE | tape_write
	return $?
}

# Retrieve and display the ToC from dump device
function toc_read
{
	tape_rewind
	if (( $? > 0 || NO_TAPE > 0 || NO_REWIND > 0 )); then
		echo "ERROR: accessing tape"
		exit 1
	fi
	$DD if=$DUMP_DEVICE
}

# Run pre/post scripts for mountpoint
# $1 = pre|post
# $2 = MOUNTPOINT
function process_scripts
{
	if (( NO_SCRIPT > 0 )); then
		echo "--> skipping $1-backup scripts for $2"
		return 0
	fi
	if [[ -f "$SCRIPT_FILE" ]]; then
		echo "--> processing $1-backup scripts for $2"
		$AWK '$1 ~ /^(pre|post)$/' $SCRIPT_FILE \
		| while read WHEN FS COMMAND; do
			if [[ "$1" == "$WHEN" && "$2" == "$FS" ]]; then
				echo "--> executing: ( $COMMAND )"
				( $COMMAND ) 2>&1 | sed 's/^/# '
			fi
		done
	else
		echo "--> skipping $1-backup scripts: $SCRIPT_FILE not found"
	fi
}

# Mail interested parties
function mail_users
{
	mailx -s "Message from $HOSTNAME: backup failed" $MAIL_USERS < $LOG_FILE
}

# Create a snapshot of a zfs filesystem
# $1 = FILESYSTEM
# $2 = MOUNTPOINT
# Result: snapshot mountpoint or normal mountpoint if snapshot fails.
function snap_create_zfs
{
	HAS_SNAP=0
	NOSNAP=$(echo $2 | $GREP -cF -f <(cat $NOSNAP_FILE | $GREP -v '#' | $GREP -v '^$'))
	if (( SNAPSHOT_ZFS > 0 && NOSNAP == 0 )); then
		echo "--> creating zfs snapshot of $2" 1>&2
		SNAPSHOT=$2/.zfs/snapshot/backup
		zfs snapshot $1@backup
		if [[ $? -eq 0 && -d $SNAPSHOT ]]; then
			echo "--> snapshot successfully created" 1>&2
			echo $SNAPSHOT
			HAS_SNAP=1
		else
			echo "--> ERROR: snapshot creation failed" 1>&2
			echo "--> proceeding with non-snap backup" 1>&2
			echo $2
		fi
	else
		echo "--> skipped creation of zfs snapshot for $2" 1>&2
		echo $2
	fi
	return $HAS_SNAP
}

# Create a snapshot of a ufs filesystem
# $1 = DEVICE
# $2 = MOUNTPOINT
# Result: snapshot device or original device if snapshot fails.
# Side-effects: sets HAS_SNAP=1 if snapshot created, 0 otherwise.
function snap_create_ufs
{
	HAS_SNAP=0
	NOSNAP=$(echo $2 | $GREP -cF -f <(cat $NOSNAP_FILE | $GREP -v '#' | $GREP -v '^$'))
	if (( SNAPSHOT_UFS > 0 && NOSNAP == 0 )); then
		echo "--> creating ufs snapshot: $2" 1>&2
		# The following prints the path to the snap device
		fssnap -F ufs -o maxsize=512m,bs=$BACKING_STORE,unlink $2
		if (( $? > 0 )); then
			echo "--> ERROR: snapshot creation failed" 1>&2
			echo "--> proceeding with non-snap backup" 1>&2
			echo $1
		else
			echo "--> snapshot successfully created" 1>&2
			HAS_SNAP=1
		fi
	else
		echo "--> skipped creation of ufs snapshot for $2" 1>&2
		echo $1
	fi
	return $HAS_SNAP
}

# Destroy the snapshot of a zfs filesystem
# $1 = FILESYSTEM
# $2 = MOUNTPOINT
# Result: nothing
function snap_delete_zfs
{
	echo "--> deleting zfs snapshot: $2"
	zfs destroy $1@backup
	if (( $? > 0 )); then
		echo "--> ERROR: snapshot deletion failed: $2"
	fi
}

# Destroy the snapshot of a ufs filesystem
# $1 = DEVICE
# $2 = MOUNTPOINT
# Result: nothing
function snap_delete_ufs
{
	echo "--> deleting ufs snapshot: $2"
	fssnap -d $2
	if (( $? > 0 )); then
		echo "--> ERROR: snapshot deletion failed: $2"
	fi
}

# Dump a zfs filesystem (snapshot) via pax
# $1 = FILESYSTEM
# $2 = MOUNTPOINT
# $3 = SNAPSHOT (mountpoint)
function dump_zfs
{
	cd $3
	if (( $? > 0 )); then
		echo "==> ERROR: $3 not found, dump of $2 failed: $(datestamp)"
		return 1
	fi
	echo "==> BEGIN: dump of $2 via pax: $(datestamp)"
	echo "--> executing: ( $PAX -w -pe -x $PAX_FORMAT -X . )"
	$PAX -w -pe -x $PAX_FORMAT -X . | tape_write
	STATUS=$?
	if (( STATUS > 0 )); then
		echo "==> ERROR: dump of $2 failed: $(datestamp)"
	else
		echo "==> COMPLETE: dump of $2 successful: $(datestamp)"
	fi
	cd - >/dev/null
	return $STATUS
}

# Dump a ufs filesystem (snapshot) via ufsdump
# $1 = DEVICE
# $2 = MOUNTPOINT
# $3 = SNAPSHOT (device)
function dump_ufs
{
	echo "==> BEGIN: dump of $2 via ufsdump: $(datestamp)"
	$UFSDUMP 0cf - $SNAPSHOT | tape_write
	STATUS=$?
	if (( STATUS > 0 )); then
		echo "==> ERROR: dump of $2 failed: $(datestamp)"
	else
		echo "==> COMPLETE: dump of $2 successful: $(datestamp)"
	fi
	return $STATUS
}

# Backup a filesystem
# $1 = FSTYPE
# $2 = DEVICE
# $3 = MOUNTPOINT
function backup_fs
{
	process_scripts pre $3
	SNAPSHOT=$(snap_create_$1 $2 $3)
	# $? > 0 implies snapshot was successful
	if (( $? > 0 )); then
		# ensure snapshot gets deleted
		trap "snap_delete_$1 $2 $3" ERR INT EXIT
		# run post-scripts early as we have a snapshot
		process_scripts post $3
	else
		# ensure post scripts get run
		trap "process_scripts post $3" ERR INT EXIT
	fi
	dump_$1 $2 $3 $SNAPSHOT
}

# Backup all local filesystems
function backup_all
{
	log_rotate
	{
		echo "===> Backup commenced: $(datestamp)"
		tape_status
		tape_rewind
		separator
		toc_create
		toc_write
		separator
		process_scripts pre ALL
		while read NUM FSTYPE DEVICE MOUNTPOINT; do
			separator
			backup_fs $FSTYPE $DEVICE $MOUNTPOINT
			(( STATUS > 0 )) && MAIL_LOG=1
		done < $TOC_FILE
		separator
		process_scripts post ALL
		separator
		tape_eject
		echo "===> Backup completed: $(datestamp)"
	} 2>&1 | log_pipe
}

# Carry out action
case $ACTION in
backup)
	backup_all; (( MAIL_LOG > 0 )) && mail_users || exit 0
	;;
check)
	log_page
	;;
toc)
	toc_read
	;;
position)
	tape_position
	;;
register)
	log_register
	;;
rotate)
	log_rotate
	;;
help)
	usage 0
	;;
*)
	echo "Not implemented"; usage 1
	;;
esac

